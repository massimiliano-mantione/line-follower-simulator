// Generated by `wit-bindgen` 0.45.0. DO NOT EDIT!
// Options used:
/// Interface for robot devices (provided by simulation host)
#[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
pub mod devices {
  #[used]
  #[doc(hidden)]
  static __FORCE_SECTION_REF: fn() =
  super::__link_custom_section_describing_imports;
  
  use super::_rt;
  /// Time represented as microseconds
  pub type TimeUs = u32;
  /// A handle to a future value
  #[repr(C)]
  #[derive(Clone, Copy)]
  pub struct FutureHandle {
    /// Unique handle identifier
    pub id: u32,
    /// The time when the future will be ready
    pub ready_at: TimeUs,
  }
  impl ::core::fmt::Debug for FutureHandle {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
      f.debug_struct("FutureHandle").field("id", &self.id).field("ready-at", &self.ready_at).finish()
    }
  }
  /// The result of a device read operation, composed of 8 bytes.
  /// Valid configurations are:
  /// - up to 8 independent u8 values, used by line sensors and enabled signal
  /// - up to 4 s16 or u16 values (adjacent bytes combined in little endian order),
  ///   used by motor angles, accel, gyro and IMU data
  /// - up to 2 s32 or u32 values (adjacent bytes combined in little endian order),
  ///   used by time values
  /// - values can be unused (unused bytes are set to zero)
  #[repr(C)]
  #[derive(Clone, Copy)]
  pub struct DeviceValue {
    pub v0: u8,
    pub v1: u8,
    pub v2: u8,
    pub v3: u8,
    pub v4: u8,
    pub v5: u8,
    pub v6: u8,
    pub v7: u8,
  }
  impl ::core::fmt::Debug for DeviceValue {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
      f.debug_struct("DeviceValue").field("v0", &self.v0).field("v1", &self.v1).field("v2", &self.v2).field("v3", &self.v3).field("v4", &self.v4).field("v5", &self.v5).field("v6", &self.v6).field("v7", &self.v7).finish()
    }
  }
  /// The set of all possible device operations
  #[derive(Clone, Copy)]
  pub enum DeviceOperation {
    /// Read left bank of line sensors (8 u8 values),
    /// ready every period
    ReadLineLeft,
    /// Read right bank of line sensors (8 u8 values),
    /// ready every period
    ReadLineRight,
    /// Read angle position of motors (2 u16 values),
    /// ready every period
    ReadMotorAngles,
    /// Read gyroscope (3 i16 values: roll, pitch and yaw angular velocity),
    /// ready every 2 periods
    ReadGyro,
    /// Read IMU fused data (3 i16 values: : roll, pitch and yaw angles),
    /// ready every 10 period
    ReadImuFusedData,
    /// Get time elapsed since initialization in microseconds (1 u32 value), always available
    GetTime,
    /// Get the simulation period microseconds (1 u32 value) and the number of periods computed so far (another u32 value), always available
    GetPeriod,
    /// Sleep for the provided duration (in microseconds, no output)
    SleepFor(TimeUs),
    /// Sleep until the provided time instant (in microseconds, no output)
    SleepUntil(TimeUs),
    /// Get the status of the `enabled` signal (1 u8 value, 0 or 1 with boolean semantics, always available)
    GetEnabled,
    /// Wait until the status of the `enabled` signal is 1
    WaitEnabled,
    /// Wait until the status of the `enabled` signal is 0
    WaitDisabled,
  }
  impl ::core::fmt::Debug for DeviceOperation {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
      match self {
        DeviceOperation::ReadLineLeft => {
          f.debug_tuple("DeviceOperation::ReadLineLeft").finish()
        }
        DeviceOperation::ReadLineRight => {
          f.debug_tuple("DeviceOperation::ReadLineRight").finish()
        }
        DeviceOperation::ReadMotorAngles => {
          f.debug_tuple("DeviceOperation::ReadMotorAngles").finish()
        }
        DeviceOperation::ReadGyro => {
          f.debug_tuple("DeviceOperation::ReadGyro").finish()
        }
        DeviceOperation::ReadImuFusedData => {
          f.debug_tuple("DeviceOperation::ReadImuFusedData").finish()
        }
        DeviceOperation::GetTime => {
          f.debug_tuple("DeviceOperation::GetTime").finish()
        }
        DeviceOperation::GetPeriod => {
          f.debug_tuple("DeviceOperation::GetPeriod").finish()
        }
        DeviceOperation::SleepFor(e) => {
          f.debug_tuple("DeviceOperation::SleepFor").field(e).finish()
        }
        DeviceOperation::SleepUntil(e) => {
          f.debug_tuple("DeviceOperation::SleepUntil").field(e).finish()
        }
        DeviceOperation::GetEnabled => {
          f.debug_tuple("DeviceOperation::GetEnabled").finish()
        }
        DeviceOperation::WaitEnabled => {
          f.debug_tuple("DeviceOperation::WaitEnabled").finish()
        }
        DeviceOperation::WaitDisabled => {
          f.debug_tuple("DeviceOperation::WaitDisabled").finish()
        }
      }
    }
  }
  /// The resulting status of a poll operation
  #[derive(Clone, Copy)]
  pub enum PollOperationStatus {
    /// The operation is pending (the value is not ready)
    Pending,
    /// The operation has completed and produced the provided value
    Ready(DeviceValue),
  }
  impl ::core::fmt::Debug for PollOperationStatus {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
      match self {
        PollOperationStatus::Pending => {
          f.debug_tuple("PollOperationStatus::Pending").finish()
        }
        PollOperationStatus::Ready(e) => {
          f.debug_tuple("PollOperationStatus::Ready").field(e).finish()
        }
      }
    }
  }
  /// The PWM duty cycle associated with the power of one motor driver
  pub type MotorPower = i16;
  #[allow(unused_unsafe, clippy::all)]
  /// Perform a device operation (returns immediately the current value if possible, not for sleep or wait operations)
  #[allow(async_fn_in_trait)]
  pub fn device_operation_immediate(operation: DeviceOperation,) -> DeviceValue{
    unsafe {

      #[repr(align(1))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
      let (result0_0,result0_1,) = match operation {
        DeviceOperation::ReadLineLeft=> {
          (0i32, 0i32)
        }
        DeviceOperation::ReadLineRight=> {
          (1i32, 0i32)
        }
        DeviceOperation::ReadMotorAngles=> {
          (2i32, 0i32)
        }
        DeviceOperation::ReadGyro=> {
          (3i32, 0i32)
        }
        DeviceOperation::ReadImuFusedData=> {
          (4i32, 0i32)
        }
        DeviceOperation::GetTime=> {
          (5i32, 0i32)
        }
        DeviceOperation::GetPeriod=> {
          (6i32, 0i32)
        }
        DeviceOperation::SleepFor(e) => (7i32, _rt::as_i32(e)),
        DeviceOperation::SleepUntil(e) => (8i32, _rt::as_i32(e)),
        DeviceOperation::GetEnabled=> {
          (9i32, 0i32)
        }
        DeviceOperation::WaitEnabled=> {
          (10i32, 0i32)
        }
        DeviceOperation::WaitDisabled=> {
          (11i32, 0i32)
        }
      };
      let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "devices")]
      unsafe extern "C" {
        #[link_name = "device-operation-immediate"]
        fn wit_import2(_: i32, _: i32, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import2(_: i32, _: i32, _: *mut u8, ) { unreachable!() }
      wit_import2(result0_0, result0_1, ptr1);
      let l3 = i32::from(*ptr1.add(0).cast::<u8>());
      let l4 = i32::from(*ptr1.add(1).cast::<u8>());
      let l5 = i32::from(*ptr1.add(2).cast::<u8>());
      let l6 = i32::from(*ptr1.add(3).cast::<u8>());
      let l7 = i32::from(*ptr1.add(4).cast::<u8>());
      let l8 = i32::from(*ptr1.add(5).cast::<u8>());
      let l9 = i32::from(*ptr1.add(6).cast::<u8>());
      let l10 = i32::from(*ptr1.add(7).cast::<u8>());
      let result11 = DeviceValue{
        v0: l3 as u8,
        v1: l4 as u8,
        v2: l5 as u8,
        v3: l6 as u8,
        v4: l7 as u8,
        v5: l8 as u8,
        v6: l9 as u8,
        v7: l10 as u8,
      };
      result11
    }
  }
  #[allow(unused_unsafe, clippy::all)]
  /// Perform a blocking operation (returns the provided value, blocking for the needed time)
  #[allow(async_fn_in_trait)]
  pub fn device_operation_blocking(operation: DeviceOperation,) -> DeviceValue{
    unsafe {

      #[repr(align(1))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
      let (result0_0,result0_1,) = match operation {
        DeviceOperation::ReadLineLeft=> {
          (0i32, 0i32)
        }
        DeviceOperation::ReadLineRight=> {
          (1i32, 0i32)
        }
        DeviceOperation::ReadMotorAngles=> {
          (2i32, 0i32)
        }
        DeviceOperation::ReadGyro=> {
          (3i32, 0i32)
        }
        DeviceOperation::ReadImuFusedData=> {
          (4i32, 0i32)
        }
        DeviceOperation::GetTime=> {
          (5i32, 0i32)
        }
        DeviceOperation::GetPeriod=> {
          (6i32, 0i32)
        }
        DeviceOperation::SleepFor(e) => (7i32, _rt::as_i32(e)),
        DeviceOperation::SleepUntil(e) => (8i32, _rt::as_i32(e)),
        DeviceOperation::GetEnabled=> {
          (9i32, 0i32)
        }
        DeviceOperation::WaitEnabled=> {
          (10i32, 0i32)
        }
        DeviceOperation::WaitDisabled=> {
          (11i32, 0i32)
        }
      };
      let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "devices")]
      unsafe extern "C" {
        #[link_name = "device-operation-blocking"]
        fn wit_import2(_: i32, _: i32, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import2(_: i32, _: i32, _: *mut u8, ) { unreachable!() }
      wit_import2(result0_0, result0_1, ptr1);
      let l3 = i32::from(*ptr1.add(0).cast::<u8>());
      let l4 = i32::from(*ptr1.add(1).cast::<u8>());
      let l5 = i32::from(*ptr1.add(2).cast::<u8>());
      let l6 = i32::from(*ptr1.add(3).cast::<u8>());
      let l7 = i32::from(*ptr1.add(4).cast::<u8>());
      let l8 = i32::from(*ptr1.add(5).cast::<u8>());
      let l9 = i32::from(*ptr1.add(6).cast::<u8>());
      let l10 = i32::from(*ptr1.add(7).cast::<u8>());
      let result11 = DeviceValue{
        v0: l3 as u8,
        v1: l4 as u8,
        v2: l5 as u8,
        v3: l6 as u8,
        v4: l7 as u8,
        v5: l8 as u8,
        v6: l9 as u8,
        v7: l10 as u8,
      };
      result11
    }
  }
  #[allow(unused_unsafe, clippy::all)]
  /// Initiate an async operation (immediately returns a handle to the future value)
  #[allow(async_fn_in_trait)]
  pub fn device_operation_async(operation: DeviceOperation,) -> FutureHandle{
    unsafe {

      #[repr(align(4))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
      let (result0_0,result0_1,) = match operation {
        DeviceOperation::ReadLineLeft=> {
          (0i32, 0i32)
        }
        DeviceOperation::ReadLineRight=> {
          (1i32, 0i32)
        }
        DeviceOperation::ReadMotorAngles=> {
          (2i32, 0i32)
        }
        DeviceOperation::ReadGyro=> {
          (3i32, 0i32)
        }
        DeviceOperation::ReadImuFusedData=> {
          (4i32, 0i32)
        }
        DeviceOperation::GetTime=> {
          (5i32, 0i32)
        }
        DeviceOperation::GetPeriod=> {
          (6i32, 0i32)
        }
        DeviceOperation::SleepFor(e) => (7i32, _rt::as_i32(e)),
        DeviceOperation::SleepUntil(e) => (8i32, _rt::as_i32(e)),
        DeviceOperation::GetEnabled=> {
          (9i32, 0i32)
        }
        DeviceOperation::WaitEnabled=> {
          (10i32, 0i32)
        }
        DeviceOperation::WaitDisabled=> {
          (11i32, 0i32)
        }
      };
      let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "devices")]
      unsafe extern "C" {
        #[link_name = "device-operation-async"]
        fn wit_import2(_: i32, _: i32, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import2(_: i32, _: i32, _: *mut u8, ) { unreachable!() }
      wit_import2(result0_0, result0_1, ptr1);
      let l3 = *ptr1.add(0).cast::<i32>();
      let l4 = *ptr1.add(4).cast::<i32>();
      let result5 = FutureHandle{
        id: l3 as u32,
        ready_at: l4 as u32,
      };
      result5
    }
  }
  #[allow(unused_unsafe, clippy::all)]
  /// Poll the status of an async operation (returns immediately)
  #[allow(async_fn_in_trait)]
  pub fn device_poll(handle: FutureHandle,) -> PollOperationStatus{
    unsafe {

      #[repr(align(1))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 9]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 9]);
      let FutureHandle{ id:id0, ready_at:ready_at0, } = handle;
      let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "devices")]
      unsafe extern "C" {
        #[link_name = "device-poll"]
        fn wit_import2(_: i32, _: i32, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import2(_: i32, _: i32, _: *mut u8, ) { unreachable!() }
      wit_import2(_rt::as_i32(id0), _rt::as_i32(ready_at0), ptr1);
      let l3 = i32::from(*ptr1.add(0).cast::<u8>());
      let v12 = match l3 {
        0 => {
          PollOperationStatus::Pending
        }
        n => {
          debug_assert_eq!(n, 1, "invalid enum discriminant");
          let e12 = {
            let l4 = i32::from(*ptr1.add(1).cast::<u8>());
            let l5 = i32::from(*ptr1.add(2).cast::<u8>());
            let l6 = i32::from(*ptr1.add(3).cast::<u8>());
            let l7 = i32::from(*ptr1.add(4).cast::<u8>());
            let l8 = i32::from(*ptr1.add(5).cast::<u8>());
            let l9 = i32::from(*ptr1.add(6).cast::<u8>());
            let l10 = i32::from(*ptr1.add(7).cast::<u8>());
            let l11 = i32::from(*ptr1.add(8).cast::<u8>());

            DeviceValue{
              v0: l4 as u8,
              v1: l5 as u8,
              v2: l6 as u8,
              v3: l7 as u8,
              v4: l8 as u8,
              v5: l9 as u8,
              v6: l10 as u8,
              v7: l11 as u8,
            }
          };
          PollOperationStatus::Ready(e12)
        }
      };
      let result13 = v12;
      result13
    }
  }
  #[allow(unused_unsafe, clippy::all)]
  /// Signal future values poll loop start and end to the simulation host
  #[allow(async_fn_in_trait)]
  pub fn poll_loop(start: bool,) -> (){
    unsafe {

      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "devices")]
      unsafe extern "C" {
        #[link_name = "poll-loop"]
        fn wit_import0(_: i32, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import0(_: i32, ) { unreachable!() }
      wit_import0(match &start { true => 1, false => 0 });
    }
  }
  #[allow(unused_unsafe, clippy::all)]
  /// Instructs the simulation to forget the handle to an async operation
  /// (is equivalent to dropping the future in Rust)
  #[allow(async_fn_in_trait)]
  pub fn forget_handle(handle: FutureHandle,) -> (){
    unsafe {
      let FutureHandle{ id:id0, ready_at:ready_at0, } = handle;

      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "devices")]
      unsafe extern "C" {
        #[link_name = "forget-handle"]
        fn wit_import1(_: i32, _: i32, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: i32, ) { unreachable!() }
      wit_import1(_rt::as_i32(id0), _rt::as_i32(ready_at0));
    }
  }
  #[allow(unused_unsafe, clippy::all)]
  /// Set the power of both motors
  #[allow(async_fn_in_trait)]
  pub fn set_motors_power(left: MotorPower,right: MotorPower,) -> (){
    unsafe {

      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "devices")]
      unsafe extern "C" {
        #[link_name = "set-motors-power"]
        fn wit_import0(_: i32, _: i32, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import0(_: i32, _: i32, ) { unreachable!() }
      wit_import0(_rt::as_i32(left), _rt::as_i32(right));
    }
  }

}

/// Interface for robot diagnostics (provided by simulation host)
#[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
pub mod diagnostics {
  #[used]
  #[doc(hidden)]
  static __FORCE_SECTION_REF: fn() =
  super::__link_custom_section_describing_imports;
  
  use super::_rt;
  /// a name associated to a value
  #[derive(Clone)]
  pub struct NamedValue {
    /// Value name
    pub name: _rt::String,
    /// Named value
    pub value: i32,
  }
  impl ::core::fmt::Debug for NamedValue {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
      f.debug_struct("NamedValue").field("name", &self.name).field("value", &self.value).finish()
    }
  }
  /// The kind of values that can be converted in CSV format
  #[derive(Clone)]
  pub enum ValueKind {
    /// One byte signed value
    Int8,
    /// Two bytes signed value
    Int16,
    /// Four bytes signed value
    Int32,
    /// One byte unsigned value
    Uint8,
    /// Two bytes unsigned value
    Uint16,
    /// Four bytes unsigned value
    Uint32,
    /// A one byte named value (each concrete value is emitted with its name)
    Named(_rt::Vec::<NamedValue>),
    /// One byte of padding
    Pad8,
    /// Two bytes of padding
    Pad16,
  }
  impl ::core::fmt::Debug for ValueKind {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
      match self {
        ValueKind::Int8 => {
          f.debug_tuple("ValueKind::Int8").finish()
        }
        ValueKind::Int16 => {
          f.debug_tuple("ValueKind::Int16").finish()
        }
        ValueKind::Int32 => {
          f.debug_tuple("ValueKind::Int32").finish()
        }
        ValueKind::Uint8 => {
          f.debug_tuple("ValueKind::Uint8").finish()
        }
        ValueKind::Uint16 => {
          f.debug_tuple("ValueKind::Uint16").finish()
        }
        ValueKind::Uint32 => {
          f.debug_tuple("ValueKind::Uint32").finish()
        }
        ValueKind::Named(e) => {
          f.debug_tuple("ValueKind::Named").field(e).finish()
        }
        ValueKind::Pad8 => {
          f.debug_tuple("ValueKind::Pad8").finish()
        }
        ValueKind::Pad16 => {
          f.debug_tuple("ValueKind::Pad16").finish()
        }
      }
    }
  }
  /// The description of a column in a CSV file
  #[derive(Clone)]
  pub struct CsvColumn {
    /// Column name
    pub name: _rt::String,
    /// Column value kind
    pub kind: ValueKind,
  }
  impl ::core::fmt::Debug for CsvColumn {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
      f.debug_struct("CsvColumn").field("name", &self.name).field("kind", &self.kind).finish()
    }
  }
  #[allow(unused_unsafe, clippy::all)]
  /// Write a line of text as a log, like writing to a serial line
  /// (each character takes 100 microseconds)
  #[allow(async_fn_in_trait)]
  pub fn write_line(text: &str,) -> (){
    unsafe {
      let vec0 = text;
      let ptr0 = vec0.as_ptr().cast::<u8>();
      let len0 = vec0.len();

      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "diagnostics")]
      unsafe extern "C" {
        #[link_name = "write-line"]
        fn wit_import1(_: *mut u8, _: usize, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: *mut u8, _: usize, ) { unreachable!() }
      wit_import1(ptr0.cast_mut(), len0);
    }
  }
  #[allow(unused_unsafe, clippy::all)]
  /// Write a buffer into a file, eventually converting it to CSV
  /// (each byte takes 10 microseconds)
  #[allow(async_fn_in_trait)]
  pub fn write_file(name: &str,data: &[u8],csv: Option<&[CsvColumn]>,) -> (){
    unsafe {
      let mut cleanup_list = _rt::Vec::new();
      let vec0 = name;
      let ptr0 = vec0.as_ptr().cast::<u8>();
      let len0 = vec0.len();
      let vec1 = data;
      let ptr1 = vec1.as_ptr().cast::<u8>();
      let len1 = vec1.len();
      let (result8_0,result8_1,result8_2,) = match csv {
        Some(e) => {
          let vec7 = e;
          let len7 = vec7.len();
          let layout7 = _rt::alloc::Layout::from_size_align(vec7.len() * (5*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
          let (result7, _cleanup7) = wit_bindgen::rt::Cleanup::new(layout7);cleanup_list.extend(_cleanup7);
          for (i, e) in vec7.into_iter().enumerate() {
            let base = result7.add(i * (5*::core::mem::size_of::<*const u8>()));
            {
              let CsvColumn{ name:name2, kind:kind2, } = e;
              let vec3 = name2;
              let ptr3 = vec3.as_ptr().cast::<u8>();
              let len3 = vec3.len();
              *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
              *base.add(0).cast::<*mut u8>() = ptr3.cast_mut();
              match kind2 {
                ValueKind::Int8=> {
                  {
                    *base.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                }
                ValueKind::Int16=> {
                  {
                    *base.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  }
                }
                ValueKind::Int32=> {
                  {
                    *base.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (2i32) as u8;
                  }
                }
                ValueKind::Uint8=> {
                  {
                    *base.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (3i32) as u8;
                  }
                }
                ValueKind::Uint16=> {
                  {
                    *base.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (4i32) as u8;
                  }
                }
                ValueKind::Uint32=> {
                  {
                    *base.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (5i32) as u8;
                  }
                }
                ValueKind::Named(e) => {
                  *base.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (6i32) as u8;
                  let vec6 = e;
                  let len6 = vec6.len();
                  let layout6 = _rt::alloc::Layout::from_size_align(vec6.len() * (3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
                  let (result6, _cleanup6) = wit_bindgen::rt::Cleanup::new(layout6);cleanup_list.extend(_cleanup6);
                  for (i, e) in vec6.into_iter().enumerate() {
                    let base = result6.add(i * (3*::core::mem::size_of::<*const u8>()));
                    {
                      let NamedValue{ name:name4, value:value4, } = e;
                      let vec5 = name4;
                      let ptr5 = vec5.as_ptr().cast::<u8>();
                      let len5 = vec5.len();
                      *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                      *base.add(0).cast::<*mut u8>() = ptr5.cast_mut();
                      *base.add(2*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(value4);
                    }
                  }
                  *base.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
                  *base.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result6;
                },
                ValueKind::Pad8=> {
                  {
                    *base.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (7i32) as u8;
                  }
                }
                ValueKind::Pad16=> {
                  {
                    *base.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (8i32) as u8;
                  }
                }
              }
            }
          }

          (1i32, result7, len7)
        },
        None => {
          (0i32, ::core::ptr::null_mut(), 0usize)
        },
      };
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "diagnostics")]
      unsafe extern "C" {
        #[link_name = "write-file"]
        fn wit_import9(_: *mut u8, _: usize, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import9(_: *mut u8, _: usize, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, ) { unreachable!() }
      wit_import9(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, result8_0, result8_1, result8_2);
    }
  }

}

#[allow(dead_code, clippy::all)]
pub mod exports {
  /// Interface for robot logic implementation (implemented by robot)
  #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
  pub mod robot {
    #[used]
    #[doc(hidden)]
    static __FORCE_SECTION_REF: fn() =
    super::super::__link_custom_section_describing_imports;
    
    use super::super::_rt;
    /// An RGB color
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct Color {
      /// Red component
      pub r: u8,
      /// Green component
      pub g: u8,
      /// Blue component
      pub b: u8,
    }
    impl ::core::fmt::Debug for Color {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("Color").field("r", &self.r).field("g", &self.g).field("b", &self.b).finish()
      }
    }
    /// The appearence and build configuration of a robot
    #[derive(Clone)]
    pub struct Configuration {
      /// Robot name
      pub name: _rt::String,
      /// Main color
      pub color_main: Color,
      /// Secondary color
      pub color_secondary: Color,
      /// Axle width from wheel to wheel (in mm, 100 to 200)
      pub width_axle: f32,
      /// Length from wheel axles to front (in mm, 100 to 300)
      pub length_front: f32,
      /// Length from wheel axles to back (in mm, 10 to 50)
      pub length_back: f32,
      /// Clearing from robot to ground at the robot back (in mm, from 1 to wheels radius)
      pub clearing_back: f32,
      /// Diameter of robot wheels (in mm, from 20 to 40)
      pub wheel_diameter: f32,
      /// Transmission gear ratio numerator (from 1 to 100)
      pub gear_ratio_num: u32,
      /// Transmission gear ratio denumerator (from 1 to 100)
      pub gear_ratio_den: u32,
      /// Spacing of line sensors (in mm, from 1 to 15)
      pub front_sensors_spacing: f32,
      /// Height of line sensors from the ground (in mm, from 1 to wheels radius)
      pub front_sensors_height: f32,
    }
    impl ::core::fmt::Debug for Configuration {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("Configuration").field("name", &self.name).field("color-main", &self.color_main).field("color-secondary", &self.color_secondary).field("width-axle", &self.width_axle).field("length-front", &self.length_front).field("length-back", &self.length_back).field("clearing-back", &self.clearing_back).field("wheel-diameter", &self.wheel_diameter).field("gear-ratio-num", &self.gear_ratio_num).field("gear-ratio-den", &self.gear_ratio_den).field("front-sensors-spacing", &self.front_sensors_spacing).field("front-sensors-height", &self.front_sensors_height).finish()
      }
    }
    #[doc(hidden)]
    #[allow(non_snake_case, unused_unsafe)]
    pub unsafe fn _export_setup_cabi<T: Guest>() -> *mut u8 { unsafe {#[cfg(target_arch="wasm32")]
    _rt::run_ctors_once();let result0 = {
      T::setup()
    };
    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
    let Configuration{ name:name2, color_main:color_main2, color_secondary:color_secondary2, width_axle:width_axle2, length_front:length_front2, length_back:length_back2, clearing_back:clearing_back2, wheel_diameter:wheel_diameter2, gear_ratio_num:gear_ratio_num2, gear_ratio_den:gear_ratio_den2, front_sensors_spacing:front_sensors_spacing2, front_sensors_height:front_sensors_height2, } = result0;
    let vec3 = (name2.into_bytes()).into_boxed_slice();
    let ptr3 = vec3.as_ptr().cast::<u8>();
    let len3 = vec3.len();
    ::core::mem::forget(vec3);
    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
    *ptr1.add(0).cast::<*mut u8>() = ptr3.cast_mut();
    let Color{ r:r4, g:g4, b:b4, } = color_main2;
    *ptr1.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (_rt::as_i32(r4)) as u8;
    *ptr1.add(1+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (_rt::as_i32(g4)) as u8;
    *ptr1.add(2+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (_rt::as_i32(b4)) as u8;
    let Color{ r:r5, g:g5, b:b5, } = color_secondary2;
    *ptr1.add(3+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (_rt::as_i32(r5)) as u8;
    *ptr1.add(4+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (_rt::as_i32(g5)) as u8;
    *ptr1.add(5+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (_rt::as_i32(b5)) as u8;
    *ptr1.add(8+2*::core::mem::size_of::<*const u8>()).cast::<f32>() = _rt::as_f32(width_axle2);
    *ptr1.add(12+2*::core::mem::size_of::<*const u8>()).cast::<f32>() = _rt::as_f32(length_front2);
    *ptr1.add(16+2*::core::mem::size_of::<*const u8>()).cast::<f32>() = _rt::as_f32(length_back2);
    *ptr1.add(20+2*::core::mem::size_of::<*const u8>()).cast::<f32>() = _rt::as_f32(clearing_back2);
    *ptr1.add(24+2*::core::mem::size_of::<*const u8>()).cast::<f32>() = _rt::as_f32(wheel_diameter2);
    *ptr1.add(28+2*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(gear_ratio_num2);
    *ptr1.add(32+2*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(gear_ratio_den2);
    *ptr1.add(36+2*::core::mem::size_of::<*const u8>()).cast::<f32>() = _rt::as_f32(front_sensors_spacing2);
    *ptr1.add(40+2*::core::mem::size_of::<*const u8>()).cast::<f32>() = _rt::as_f32(front_sensors_height2);
    ptr1
  } }
  #[doc(hidden)]
  #[allow(non_snake_case)]
  pub unsafe fn __post_return_setup<T: Guest>(arg0: *mut u8,) { unsafe {
    let l0 = *arg0.add(0).cast::<*mut u8>();
    let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
    _rt::cabi_dealloc(l0, l1, 1);
  } }
  #[doc(hidden)]
  #[allow(non_snake_case, unused_unsafe)]
  pub unsafe fn _export_run_cabi<T: Guest>() { unsafe {#[cfg(target_arch="wasm32")]
  _rt::run_ctors_once();{
    T::run()
  };
} }
pub trait Guest {
  /// Provide robot configuration (is invoked exactly once at the beginning of the simulation)
  #[allow(async_fn_in_trait)]
  fn setup() -> Configuration;
  /// Robot logic (is invoked exactly once after setup)
  #[allow(async_fn_in_trait)]
  fn run() -> ();
}
#[doc(hidden)]

macro_rules! __export_robot_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[unsafe(export_name = "robot#setup")]
    unsafe extern "C" fn export_setup() -> *mut u8 {
      unsafe { $($path_to_types)*::_export_setup_cabi::<$ty>() }
    }
    #[unsafe(export_name = "cabi_post_robot#setup")]
    unsafe extern "C" fn _post_return_setup(arg0: *mut u8,) {
      unsafe { $($path_to_types)*::__post_return_setup::<$ty>(arg0) }
    }
    #[unsafe(export_name = "robot#run")]
    unsafe extern "C" fn export_run() {
      unsafe { $($path_to_types)*::_export_run_cabi::<$ty>() }
    }
  };);
}
#[doc(hidden)]
pub(crate) use __export_robot_cabi;

#[cfg_attr(target_pointer_width="64", repr(align(8)))]
#[cfg_attr(target_pointer_width="32", repr(align(4)))]
struct _RetArea([::core::mem::MaybeUninit::<u8>; 40+3*::core::mem::size_of::<*const u8>()]);
static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 40+3*::core::mem::size_of::<*const u8>()]);

}

}
mod _rt {
  #![allow(dead_code, clippy::all)]

  pub fn as_i32<T: AsI32>(t: T) -> i32 {
    t.as_i32()
  }

  pub trait AsI32 {
    fn as_i32(self) -> i32;
  }

  impl<'a, T: Copy + AsI32> AsI32 for &'a T {
    fn as_i32(self) -> i32 {
      (*self).as_i32()
    }
  }
  
  impl AsI32 for i32 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u32 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for i16 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u16 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for i8 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u8 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for char {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for usize {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  pub use alloc_crate::string::String;
  pub use alloc_crate::vec::Vec;
  pub use alloc_crate::alloc;

  #[cfg(target_arch = "wasm32")]
  pub fn run_ctors_once() {
    wit_bindgen::rt::run_ctors_once();
  }
  
  pub fn as_f32<T: AsF32>(t: T) -> f32 {
    t.as_f32()
  }

  pub trait AsF32 {
    fn as_f32(self) -> f32;
  }

  impl<'a, T: Copy + AsF32> AsF32 for &'a T {
    fn as_f32(self) -> f32 {
      (*self).as_f32()
    }
  }
  
  impl AsF32 for f32 {
    #[inline]
    fn as_f32(self) -> f32 {
      self as f32
    }
  }
  pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
    if size == 0 {
      return;
    }
    unsafe {
      let layout = alloc::Layout::from_size_align_unchecked(size, align);
      alloc::dealloc(ptr, layout);
    }
  }
  extern crate alloc as alloc_crate;
}

/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]

macro_rules! __export_line_follower_robot_impl {
  ($ty:ident) => (self::export!($ty with_types_in self););
  ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
  $($path_to_types_root)*::exports::robot::__export_robot_cabi!($ty with_types_in $($path_to_types_root)*::exports::robot);
  )
}
#[doc(inline)]
pub(crate) use __export_line_follower_robot_impl as export;

#[cfg(target_arch = "wasm32")]
#[unsafe(link_section = "component-type:wit-bindgen:0.45.0:component:line-follower-robot:line-follower-robot:encoded world")]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1359] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xc5\x09\x01A\x02\x01\
A\x06\x01B\x19\x01y\x04\0\x07time-us\x03\0\0\x01r\x02\x02idy\x08ready-at\x01\x04\
\0\x0dfuture-handle\x03\0\x02\x01r\x08\x02v0}\x02v1}\x02v2}\x02v3}\x02v4}\x02v5}\
\x02v6}\x02v7}\x04\0\x0cdevice-value\x03\0\x04\x01q\x0c\x0eread-line-left\0\0\x0f\
read-line-right\0\0\x11read-motor-angles\0\0\x09read-gyro\0\0\x13read-imu-fused-\
data\0\0\x08get-time\0\0\x0aget-period\0\0\x09sleep-for\x01\x01\0\x0bsleep-until\
\x01\x01\0\x0bget-enabled\0\0\x0cwait-enabled\0\0\x0dwait-disabled\0\0\x04\0\x10\
device-operation\x03\0\x06\x01q\x02\x07pending\0\0\x05ready\x01\x05\0\x04\0\x15p\
oll-operation-status\x03\0\x08\x01|\x04\0\x0bmotor-power\x03\0\x0a\x01@\x01\x09o\
peration\x07\0\x05\x04\0\x1adevice-operation-immediate\x01\x0c\x04\0\x19device-o\
peration-blocking\x01\x0c\x01@\x01\x09operation\x07\0\x03\x04\0\x16device-operat\
ion-async\x01\x0d\x01@\x01\x06handle\x03\0\x09\x04\0\x0bdevice-poll\x01\x0e\x01@\
\x01\x05start\x7f\x01\0\x04\0\x09poll-loop\x01\x0f\x01@\x01\x06handle\x03\x01\0\x04\
\0\x0dforget-handle\x01\x10\x01@\x02\x04left\x0b\x05right\x0b\x01\0\x04\0\x10set\
-motors-power\x01\x11\x03\0\x07devices\x05\0\x01B\x0e\x01r\x02\x04names\x05value\
z\x04\0\x0bnamed-value\x03\0\0\x01p\x01\x01q\x09\x04int8\0\0\x05int16\0\0\x05int\
32\0\0\x05uint8\0\0\x06uint16\0\0\x06uint32\0\0\x05named\x01\x02\0\x04pad8\0\0\x05\
pad16\0\0\x04\0\x0avalue-kind\x03\0\x03\x01r\x02\x04names\x04kind\x04\x04\0\x0ac\
sv-column\x03\0\x05\x01@\x01\x04texts\x01\0\x04\0\x0awrite-line\x01\x07\x01p}\x01\
p\x06\x01k\x09\x01@\x03\x04names\x04data\x08\x03csv\x0a\x01\0\x04\0\x0awrite-fil\
e\x01\x0b\x03\0\x0bdiagnostics\x05\x01\x01B\x08\x01r\x03\x01r}\x01g}\x01b}\x04\0\
\x05color\x03\0\0\x01r\x0c\x04names\x0acolor-main\x01\x0fcolor-secondary\x01\x0a\
width-axlev\x0clength-frontv\x0blength-backv\x0dclearing-backv\x0ewheel-diameter\
v\x0egear-ratio-numy\x0egear-ratio-deny\x15front-sensors-spacingv\x14front-senso\
rs-heightv\x04\0\x0dconfiguration\x03\0\x02\x01@\0\0\x03\x04\0\x05setup\x01\x04\x01\
@\0\x01\0\x04\0\x03run\x01\x05\x04\0\x05robot\x05\x02\x04\01component:line-follo\
wer-robot/line-follower-robot\x04\0\x0b\x19\x01\0\x13line-follower-robot\x03\0\0\
\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-component\x070.238.0\x10wit-bind\
gen-rust\x060.45.0";

#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
  wit_bindgen::rt::maybe_link_cabi_realloc();
}

