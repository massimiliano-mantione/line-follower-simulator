package component:line-follower-robot;

world line-follower-robot {
    /// Interface for robot devices (provided by simulation host)
    import devices: interface {
        /// Errors that can happen when polling devices asynchronously
        enum poll-error {
            /// The provided handle is not valid
            /// (this handle has never been created)
            invalid-handle,
            /// The provided handle has already been consumed
            /// (the detection of this case is best-effort,
            /// otherwise the handle is reported as expired)
            consumed-handle,
            /// The provided handle is too old and its value has been lost
            /// (more recent values are available and replace the old one)
            expired-handle,
        }

        /// Time represented as microseconds
        type time-us = u32;
        /// A handle to a future value
        type future-handle = u32;

        /// The result of a device read operation, composed of 8 bytes.
        /// Valid configurations are:
        /// - up to 8 independent u8 values, used by line sensors and enabled signal
        /// - up to 4 s16 or u16 values (adjacent bytes combined in little endian order),
        ///   used by motor angles, accel, gyro and IMU data
        /// - up to 2 s32 or u32 values (adjacent bytes combined in little endian order),
        ///   used by time values
        /// - values can be unused (unused bytes are set to zero)
        record device-value {
            v0: u8,
            v1: u8,
            v2: u8,
            v3: u8,
            v4: u8,
            v5: u8,
            v6: u8,
            v7: u8,
        }

        /// The set of all possible device operations
        variant device-operation {
            /// Read left bank of line sensors (8 u8 values),
            /// ready every 100us
            read-line-left,
            /// Read right bank of line sensors (8 u8 values),
            /// ready every 100us
            read-line-right,
            /// Read angle position of motors (2 u16 values),
            /// ready every 100us
            read-motor-angles,
            /// Read accelerometer (3 i16 values: front, side and vertical acceleration),
            /// ready every 100us
            read-accel,
            /// Read gyroscope (3 i16 values: roll, pitch and yaw angular velocity),
            /// ready every 100us
            read-gyro,
            /// Read IMU fused data (3 i16 values: : roll, pitch and yaw angles),
            /// ready every 10_000us
            read-imu-fused-data,
            /// Get time elapsed since initialization in microseconds (1 u32 value), always available
            get-time,
            /// Sleep for the provided duration (in microseconds, no output)
            sleep-for(time-us),
            /// Sleep until the provided time instant (in microseconds, no output)
            sleep-until(time-us),
            /// Get the status of the `enabled` signal (1 u8 value, 0 or 1 with boolean semantics, always available)
            get-enabled,
            /// Wait until the status of the `enabled` signal is 1
            wait-enabled,
            /// Wait until the status of the `enabled` signal is 0
            wait-disabled,
        }

        /// The resulting status of a poll operation
        variant poll-operation-status {
            /// The operation is pending (the value is not ready)
            pending,
            /// The operation has completed and produced the provided value
            ready(device-value),
        }

        /// Perform a blocking operation (returns the provided value, blocking for the needed time)
        device-operation-blocking: func(operation: device-operation) -> device-value;

        /// Initiate and async operation (immediately returns a handle to the future value)
        device-operation-async: func(operation: device-operation) -> future-handle;

        /// Poll the status of an async operation (returns immediately)
        device-poll: func(handle: future-handle) -> result<poll-operation-status, poll-error>;

        /// Wait for an async operation (returns when ready with the result or immediately with an error)
        device-wait: func(handle: future-handle) -> result<device-value, poll-error>;

        /// Instructs the simulation to forget the handle to an async operation
        /// (is equivalent to dropping the future in Rust)
        forget-handle: func(handle: future-handle);

        /// The PWM duty cycle associated with the power of one motor driver
        type motor-power = s16;

        /// Set the power of both motors
        set-motors-power: func(left: motor-power, right: motor-power);
    }

    /// Interface for robot diagnostics (provided by simulation host)
    import diagnostics: interface {
        /// a name associated to a value
        record named-value {
            /// Value name
            name: string,
            /// Named value
            value: s32,
        }

        /// The kind of values that can be converted in CSV format
        variant value-kind {
            /// One byte signed value
            int8,
            /// Two bytes signed value
            int16,
            /// Four bytes signed value
            int32,
            /// One byte unsigned value
            uint8,
            /// Two bytes unsigned value
            uint16,
            /// Four bytes unsigned value
            uint32,
            /// A one byte named value (each concrete value is emitted with its name)
            named(list<named-value>),
            /// One byte of padding
            pad8,
            /// Two bytes of padding
            pad16,
        }

        /// The description of a column in a CSV file
        record csv-column {
            /// Column name
            name: string,
            /// Column value kind
            kind: value-kind,
        }

        /// Write a line of text as a log, like writing to a serial line
        /// (each character takes 100 microseconds)
        write-line: func(text: string);

        /// Write a buffer into a file, eventually converting it to CSV
        /// (each byte takes 10 microseconds)
        write-file: func(name: string, data: list<u8>, csv: option<list<csv-column>>);
    }

    /// Interface for robot logic implementation (implemented by robot)
    export robot: interface {
        /// An RGB color
        record color {
            /// Red component
            r: u8,
            /// Green component
            g: u8,
            /// Blue component
            b: u8,
        }

        /// The appearence and build configuration of a robot
        record configuration {
            /// Robot name
            name: string,
            /// Main color
            color-main: color,
            /// Secondary color
            color-secondary: color,

            /// Axle width from wheel to wheel (in mm, 100 to 200)
            width-axle: f32,
            /// Length from wheel axles to front (in mm, 100 to 300)
            length-front: f32,
            /// Length from wheel axles to back (in mm, 10 to 50)
            length-back: f32,
            /// Clearing from robot to ground at the robot back (in mm, from 1 to wheels radius)
            clearing-back: f32,

            /// Diameter of robot wheels (in mm, from 20 to 40)
            wheel-diameter: f32,
            /// Transmission gear ratio numerator (from 1 to 100)
            gear-ratio-num: u32,
            /// Transmission gear ratio denumerator (from 1 to 100)
            gear-ratio-den: u32,

            /// Spacing of line sensors (in mm, from 1 to 15)
            front-sensors-spacing: f32,
            /// Height of line sensors from the ground (in mm, from 1 to wheels radius)
            front-sensors-height: f32,
        }

        /// Provide robot configuration (is invoked exactly once at the beginning of the simulation)
        setup: func() -> configuration;
        /// Robot logic (is invoked exactly once after setup)
        run: func();
    }
}
